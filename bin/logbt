#!/usr/bin/env bash

set -eu
set -o pipefail
shopt -s nullglob

function error() {
  >&2 echo "$@"
  exit 1
}

function process_core() {
  local program=${1}
  local corefile=${2}
  if [[ $(uname -s) == 'Darwin' ]]; then
    lldb --core ${corefile} --batch -o 'thread backtrace all' -o 'quit'
  else
    gdb ${program} --core ${corefile} -ex "set pagination 0" -ex "thread apply all bt" --batch
  fi
  # note: on OS X the -f avoids a hang on prompt 'remove write-protected regular file?'
  rm -f ${corefile}
}

function backtrace {
  local code=$?
  local program=${1}
  local core_directory=${2}
  echo "${program} exited with code:${code}"
  if [[ $(uname -s) == 'Darwin' ]]; then
    local single_corefile="${core_directory}/core.${CHILD_PID}"
    if [ -e ${single_corefile} ]; then
      echo "Found corefile at ${single_corefile}"
      process_core ${program} ${single_corefile}
    else
      if [[ ${code} != 0 ]]; then
          echo "No corefile found at ${single_corefile}"
      fi
    fi
  else
    local SEARCH_PATTERN_BY_PID="core.${CHILD_PID}.*"
    local hit=false
    for corefile in ${core_directory}/${SEARCH_PATTERN_BY_PID}; do
      echo "Found corefile at ${corefile}"
      # extract program name from corefile
      filename=$(basename "${corefile}")
      binary_program=/$(echo ${filename##*.\!} | tr '!' '/')
      process_core ${binary_program} ${corefile}
      hit=true
    done
    if [[ ${hit} == false ]] && [[ ${code} != 0 ]]; then
        echo "No corefile found at ${core_directory}/${SEARCH_PATTERN_BY_PID}"
    fi
  fi
  local SEARCH_PATTERN_NON_TRACKED="core.*"
  local hit=false
  for corefile in ${core_directory}/${SEARCH_PATTERN_NON_TRACKED}; do
    echo "Found corefile (non-tracked) at ${corefile}"
    hit=true
  done
  if [[ ${code} != 0 ]]; then
    if [[ ${hit} == true ]]; then
      echo "Processing cores..."
    fi
    for corefile in ${core_directory}/${SEARCH_PATTERN_NON_TRACKED}; do
      filename=$(basename "${corefile}")
      binary_program=/$(echo ${filename##*.\!} | tr '!' '/')
      process_core ${binary_program} ${corefile}
    done
  else
    if [[ ${hit} == true ]]; then
      echo "Skipping processing cores..."
    fi
  fi
  exit $code
}

function warn_on_existing_cores() {
  local core_directory=${1}
  local SEARCH_PATTERN_NON_TRACKED="core.*"
  # at startup warn about existing corefiles, since these are unexpected
  for corefile in ${core_directory}/${SEARCH_PATTERN_NON_TRACKED}; do
    echo "WARNING: Found corefile (existing) at ${corefile}"
  done
}

function launch_and_wait() {
  local core_directory=/tmp/logbt-coredumps
  if [[ $(uname -s) == 'Linux' ]]; then
    if ! which gdb > /dev/null; then
      error "Could not find required command 'gdb'"
    fi

    # if we have sudo then set core pattern
    if [[ $(id -u) == 0 ]]; then
      echo "Setting $(cat /proc/sys/kernel/core_pattern) -> ${core_directory}/core.%p.%E"
      echo "${core_directory}/core.%p.%E" > /proc/sys/kernel/core_pattern
    else
      # if we cannot modify the pattern we assert it has
      # already been set as we expect and need
      if [[ $(cat /proc/sys/kernel/core_pattern) != '/tmp/logbt-coredumps/core.%p.%E' ]]; then
        error "unexpected core_pattern: $(cat /proc/sys/kernel/core_pattern)"
        exit 1
      fi
      echo "Using existing corefile location: $(cat /proc/sys/kernel/core_pattern)"
    fi
  else
    if ! which lldb > /dev/null; then
      error "Could not find required command 'lldb'"
      exit 1
    fi

    # if we have sudo then set core pattern
    if [[ $(id -u) == 0 ]]; then
      sudo sysctl kern.corefile=${core_directory}/core.%P
    else
      if [[ $(sysctl -n kern.corefile) == '/cores/core.%P' ]]; then
        # OS X default is /cores/core.%P which works for logbt out of the box
        core_directory=/cores
      elif [[ $(sysctl -n kern.corefile) == '${core_directory}/core.%P' ]]; then
        # all good, previously set
        :
      else
        # restore default with:
        # sudo sysctl kern.corefile=/cores/core.%P
        error "unexpected core_pattern: $(sysctl -n kern.corefile)"
        exit 1
      fi
      echo "Using existing corefile location: $(sysctl -n kern.corefile)"
    fi

    # Recommend running with the following setting to only show crashes
    # in the notification center
    # defaults write com.apple.CrashReporter UseUNC 1
  fi

  if [[ ! -d ${core_directory} ]]; then
    # TODO: enable this once tests are adapted to extra stdout
    # echo "Creating directory for core files at '${core_directory}'"
    mkdir -p ${core_directory}
  fi

  # ensure we can write to the directory, otherwise
  # core files might not be able to be written
  WRITE_RETURN=0
  touch ${core_directory}/test.txt || WRITE_RETURN=$?
  if [[ ${WRITE_RETURN} != 0 ]]; then
    error "Permissions problem: unable to write to ${core_directory} (exited with ${WRITE_RETURN})"
    exit 1
  else
    # cleanup from test
    rm ${core_directory}/test.txt
  fi
  warn_on_existing_cores ${core_directory}

  # Hook up function to run when logbt exits
  trap "backtrace $1 ${core_directory}" EXIT

  # Enable corefile generation
  ulimit -c unlimited

  # Run the child process in a background process
  # in order to get the PID
  $* & export CHILD_PID=$!

  # Keep logbt running as long as the child is running
  # to be able to hook into a potential crash
  wait ${CHILD_PID}  
}

launch_and_wait $@
